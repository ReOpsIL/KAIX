//! Planning engine and task management

use crate::utils::errors::KaiError;
use serde::{Deserialize, Serialize};
use std::collections::{HashMap, VecDeque};
use uuid::Uuid;

pub mod manager;

/// Represents a complete execution plan
/// 
/// A Plan is a structured sequence of tasks that accomplish a specific goal.
/// Plans are generated by LLMs based on user prompts and project context.
/// Each plan contains metadata about its creation, status, and a list of tasks to execute.
/// 
/// # Example
/// 
/// ```rust
/// use kai_x::planning::{Plan, Task, TaskType};
/// 
/// // Create a new plan
/// let mut plan = Plan::new("Refactor authentication module");
/// 
/// // Add tasks to the plan
/// let read_task = Task::new("task_1", "Read auth.rs file", TaskType::ReadFile)
///     .with_parameter("path", "src/auth.rs");
/// 
/// let analyze_task = Task::new("task_2", "Analyze current auth implementation", TaskType::AnalyzeCode)
///     .with_parameter("path", "src/auth.rs")
///     .with_dependency("task_1");
/// 
/// plan.add_task(read_task);
/// plan.add_task(analyze_task);
/// 
/// println!("Plan: {} with {} tasks", plan.description, plan.tasks.len());
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Plan {
    /// Unique identifier for the plan
    pub id: String,
    /// Human-readable description of what this plan accomplishes
    pub description: String,
    /// List of tasks to execute
    pub tasks: Vec<Task>,
    /// Current status of the plan
    pub status: PlanStatus,
    /// When the plan was created
    pub created_at: chrono::DateTime<chrono::Utc>,
    /// When the plan was last updated
    pub updated_at: chrono::DateTime<chrono::Utc>,
}

/// Status of a plan
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PlanStatus {
    /// Plan is ready to execute
    Ready,
    /// Plan is currently executing
    Executing,
    /// Plan execution was paused
    Paused,
    /// Plan completed successfully
    Completed,
    /// Plan failed during execution
    Failed,
    /// Plan was cancelled
    Cancelled,
}

/// Represents a single executable task within a plan
/// 
/// Tasks are the atomic units of work within a plan. Each task has a specific type
/// (e.g., reading a file, executing a command, generating content) and parameters
/// that define how it should be executed. Tasks can have dependencies on other tasks
/// and track their execution status and results.
/// 
/// # Example
/// 
/// ```rust
/// use kai_x::planning::{Task, TaskType};
/// 
/// // Create a file reading task
/// let read_task = Task::new("read_config", "Read configuration file", TaskType::ReadFile)
///     .with_parameter("path", "/etc/app/config.toml");
/// 
/// // Create a command execution task that depends on the read task
/// let backup_task = Task::new("backup_config", "Backup configuration", TaskType::ExecuteCommand)
///     .with_parameter("command", "cp /etc/app/config.toml /etc/app/config.toml.bak")
///     .with_dependency("read_config");
/// 
/// println!("Task: {} ({})", backup_task.description, backup_task.id);
/// println!("Dependencies: {:?}", backup_task.dependencies);
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Task {
    /// Unique identifier for the task
    pub id: String,
    /// Human-readable description of the task
    pub description: String,
    /// Type of task to execute
    pub task_type: TaskType,
    /// Task-specific parameters
    pub parameters: HashMap<String, serde_json::Value>,
    /// List of task IDs that must complete before this task can run
    pub dependencies: Vec<String>,
    /// Current status of the task
    pub status: TaskStatus,
    /// Result of task execution (if completed)
    pub result: Option<TaskResult>,
    /// When the task was created
    pub created_at: chrono::DateTime<chrono::Utc>,
    /// When the task was last updated
    pub updated_at: chrono::DateTime<chrono::Utc>,
}

/// Types of tasks that can be executed
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "snake_case")]
pub enum TaskType {
    /// Read content from a file
    ReadFile,
    /// Write content to a file
    WriteFile,
    /// Execute a shell command
    ExecuteCommand,
    /// Generate content using LLM
    GenerateContent,
    /// Analyze existing code
    AnalyzeCode,
    /// List files in a directory
    ListFiles,
    /// Create a directory
    CreateDirectory,
    /// Delete a file or directory
    Delete,
}

/// Status of a task
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum TaskStatus {
    /// Task is waiting to be executed
    Pending,
    /// Task is ready to execute (all dependencies satisfied)
    Ready,
    /// Task is currently executing
    InProgress,
    /// Task completed successfully
    Completed,
    /// Task failed during execution
    Failed,
    /// Task was skipped
    Skipped,
}

/// Result of task execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TaskResult {
    /// Whether the task succeeded
    pub success: bool,
    /// Output/result data from the task
    pub output: Option<serde_json::Value>,
    /// Error message if the task failed
    pub error: Option<String>,
    /// Execution time in milliseconds
    pub execution_time_ms: u64,
    /// Any additional metadata
    pub metadata: HashMap<String, serde_json::Value>,
}

impl Plan {
    /// Create a new plan
    pub fn new<S: Into<String>>(description: S) -> Self {
        let now = chrono::Utc::now();
        Self {
            id: Uuid::new_v4().to_string(),
            description: description.into(),
            tasks: Vec::new(),
            status: PlanStatus::Ready,
            created_at: now,
            updated_at: now,
        }
    }

    /// Add a task to the plan
    pub fn add_task(&mut self, mut task: Task) {
        task.updated_at = chrono::Utc::now();
        self.tasks.push(task);
        self.updated_at = chrono::Utc::now();
    }

    /// Get tasks that are ready to execute (all dependencies satisfied)
    pub fn get_ready_tasks(&self) -> Vec<&Task> {
        self.tasks
            .iter()
            .filter(|task| {
                task.status == TaskStatus::Pending
                    && task
                        .dependencies
                        .iter()
                        .all(|dep_id| self.is_task_completed(dep_id))
            })
            .collect()
    }

    /// Check if a task is completed
    pub fn is_task_completed(&self, task_id: &str) -> bool {
        self.tasks
            .iter()
            .find(|task| task.id == task_id)
            .map(|task| task.status == TaskStatus::Completed)
            .unwrap_or(false)
    }

    /// Update task status
    pub fn update_task_status(&mut self, task_id: &str, status: TaskStatus) -> Result<(), KaiError> {
        let task = self
            .tasks
            .iter_mut()
            .find(|task| task.id == task_id)
            .ok_or_else(|| KaiError::planning(format!("Task not found: {}", task_id)))?;

        task.status = status;
        task.updated_at = chrono::Utc::now();
        self.updated_at = chrono::Utc::now();

        // Update plan status based on task statuses
        self.update_plan_status();

        Ok(())
    }

    /// Set task result
    pub fn set_task_result(&mut self, task_id: &str, result: TaskResult) -> Result<(), KaiError> {
        let task = self
            .tasks
            .iter_mut()
            .find(|task| task.id == task_id)
            .ok_or_else(|| KaiError::planning(format!("Task not found: {}", task_id)))?;

        task.result = Some(result.clone());
        task.status = if result.success {
            TaskStatus::Completed
        } else {
            TaskStatus::Failed
        };
        task.updated_at = chrono::Utc::now();
        self.updated_at = chrono::Utc::now();

        // Update plan status
        self.update_plan_status();

        Ok(())
    }

    /// Update the plan status based on task statuses
    fn update_plan_status(&mut self) {
        if self.tasks.is_empty() {
            return;
        }

        let completed_tasks = self.tasks.iter().filter(|t| t.status == TaskStatus::Completed).count();
        let failed_tasks = self.tasks.iter().filter(|t| t.status == TaskStatus::Failed).count();
        let in_progress_tasks = self.tasks.iter().filter(|t| t.status == TaskStatus::InProgress).count();

        if failed_tasks > 0 {
            self.status = PlanStatus::Failed;
        } else if completed_tasks == self.tasks.len() {
            self.status = PlanStatus::Completed;
        } else if in_progress_tasks > 0 {
            self.status = PlanStatus::Executing;
        }
    }

    /// Create a plan from JSON representation
    pub fn from_json(json: &serde_json::Value) -> Result<Self, KaiError> {
        let description = json["description"]
            .as_str()
            .ok_or_else(|| KaiError::planning("Missing 'description' field"))?
            .to_string();

        let tasks_json = json["tasks"]
            .as_array()
            .ok_or_else(|| KaiError::planning("Missing or invalid 'tasks' field"))?;

        let mut plan = Plan::new(description);

        for task_json in tasks_json {
            let task = Task::from_json(task_json)?;
            plan.add_task(task);
        }

        Ok(plan)
    }

    /// Convert plan to JSON
    pub fn to_json(&self) -> Result<serde_json::Value, KaiError> {
        Ok(serde_json::to_value(self)?)
    }
}

impl Task {
    /// Create a new task
    pub fn new<S: Into<String>>(id: S, description: S, task_type: TaskType) -> Self {
        let now = chrono::Utc::now();
        Self {
            id: id.into(),
            description: description.into(),
            task_type,
            parameters: HashMap::new(),
            dependencies: Vec::new(),
            status: TaskStatus::Pending,
            result: None,
            created_at: now,
            updated_at: now,
        }
    }

    /// Add a parameter to the task
    pub fn with_parameter<K, V>(mut self, key: K, value: V) -> Self
    where
        K: Into<String>,
        V: Serialize,
    {
        if let Ok(json_value) = serde_json::to_value(value) {
            self.parameters.insert(key.into(), json_value);
        }
        self
    }

    /// Add a dependency
    pub fn with_dependency<S: Into<String>>(mut self, task_id: S) -> Self {
        self.dependencies.push(task_id.into());
        self
    }

    /// Create a task from JSON representation
    pub fn from_json(json: &serde_json::Value) -> Result<Self, KaiError> {
        let id = json["id"]
            .as_str()
            .ok_or_else(|| KaiError::planning("Missing 'id' field in task"))?
            .to_string();

        let description = json["description"]
            .as_str()
            .ok_or_else(|| KaiError::planning("Missing 'description' field in task"))?
            .to_string();

        let task_type_str = json["task_type"]
            .as_str()
            .ok_or_else(|| KaiError::planning("Missing 'task_type' field in task"))?;

        let task_type = match task_type_str {
            "read_file" => TaskType::ReadFile,
            "write_file" => TaskType::WriteFile,
            "execute_command" => TaskType::ExecuteCommand,
            "generate_content" => TaskType::GenerateContent,
            "analyze_code" => TaskType::AnalyzeCode,
            "list_files" => TaskType::ListFiles,
            "create_directory" => TaskType::CreateDirectory,
            "delete" => TaskType::Delete,
            _ => return Err(KaiError::planning(format!("Unknown task type: {}", task_type_str))),
        };

        let parameters = json["parameters"]
            .as_object()
            .map(|obj| {
                obj.iter()
                    .map(|(k, v)| (k.clone(), v.clone()))
                    .collect::<HashMap<String, serde_json::Value>>()
            })
            .unwrap_or_default();

        let dependencies = json["dependencies"]
            .as_array()
            .map(|arr| {
                arr.iter()
                    .filter_map(|v| v.as_str().map(|s| s.to_string()))
                    .collect()
            })
            .unwrap_or_default();

        let mut task = Task::new(id, description, task_type);
        task.parameters = parameters;
        task.dependencies = dependencies;

        Ok(task)
    }
}

impl TaskResult {
    /// Create a successful task result
    pub fn success(output: Option<serde_json::Value>, execution_time_ms: u64) -> Self {
        Self {
            success: true,
            output,
            error: None,
            execution_time_ms,
            metadata: HashMap::new(),
        }
    }

    /// Create a failed task result
    pub fn failure<S: Into<String>>(error: S, execution_time_ms: u64) -> Self {
        Self {
            success: false,
            output: None,
            error: Some(error.into()),
            execution_time_ms,
            metadata: HashMap::new(),
        }
    }

    /// Add metadata to the result
    pub fn with_metadata<K, V>(mut self, key: K, value: V) -> Self
    where
        K: Into<String>,
        V: Serialize,
    {
        if let Ok(json_value) = serde_json::to_value(value) {
            self.metadata.insert(key.into(), json_value);
        }
        self
    }
}