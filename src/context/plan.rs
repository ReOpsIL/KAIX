//! Plan context for managing temporary state during plan execution

use crate::planning::{Task, TaskResult};
use serde::{Deserialize, Serialize};
use std::collections::{HashMap, VecDeque};
use chrono::{DateTime, Utc};
use uuid::Uuid;

/// Temporary context that exists only during plan execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PlanContext {
    /// Unique identifier for the plan this context belongs to
    pub plan_id: String,
    /// Map of task IDs to their execution results
    pub task_results: HashMap<String, TaskResult>,
    /// Map of variable names to their values (for inter-task communication)
    pub variables: HashMap<String, serde_json::Value>,
    /// Accumulated outputs from tasks (for building final results)
    pub outputs: Vec<PlanOutput>,
    /// Task execution history for dependency resolution
    pub execution_history: VecDeque<TaskExecution>,
    /// Dependency graph for tracking task relationships
    pub dependency_graph: HashMap<String, Vec<String>>,
    /// Cached task outputs for quick dependency resolution
    pub dependency_cache: HashMap<String, TaskDependencyData>,
    /// Statistics about plan execution
    pub stats: PlanExecutionStats,
    /// When this context was created
    pub created_at: DateTime<Utc>,
    /// When this context was last updated
    pub updated_at: DateTime<Utc>,
}

/// Represents an output entry in the plan context
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PlanOutput {
    /// Unique ID for this output
    pub id: String,
    /// ID of the task that generated this output
    pub task_id: String,
    /// Human-readable description of the output
    pub description: String,
    /// The actual output data
    pub data: serde_json::Value,
    /// Type of output (file_content, command_output, analysis_result, etc.)
    pub output_type: String,
    /// Size of the output in bytes (for memory management)
    pub size_bytes: usize,
    /// Whether this output is available for dependencies
    pub available_for_dependencies: bool,
    /// Tags for categorizing and searching outputs
    pub tags: Vec<String>,
    /// When this output was generated
    pub timestamp: DateTime<Utc>,
}

/// Represents a task execution event in the history
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TaskExecution {
    /// ID of the executed task
    pub task_id: String,
    /// Task description
    pub task_description: String,
    /// Execution start time
    pub started_at: DateTime<Utc>,
    /// Execution end time
    pub completed_at: Option<DateTime<Utc>>,
    /// Whether the task succeeded
    pub success: bool,
    /// Duration in milliseconds
    pub duration_ms: Option<u64>,
    /// Error message if task failed
    pub error: Option<String>,
    /// IDs of outputs generated by this task
    pub output_ids: Vec<String>,
}

/// Cached data for task dependencies
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TaskDependencyData {
    /// Task ID that generated this data
    pub source_task_id: String,
    /// Key data extracted for dependencies
    pub key_data: serde_json::Value,
    /// Summary of the data
    pub summary: String,
    /// When this data was cached
    pub cached_at: DateTime<Utc>,
    /// Size of the data in bytes
    pub size_bytes: usize,
}

/// Statistics about plan execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PlanExecutionStats {
    /// Total number of tasks executed
    pub total_tasks_executed: usize,
    /// Number of successful tasks
    pub successful_tasks: usize,
    /// Number of failed tasks
    pub failed_tasks: usize,
    /// Total execution time in milliseconds
    pub total_execution_time_ms: u64,
    /// Average task execution time
    pub avg_task_time_ms: u64,
    /// Total size of outputs generated
    pub total_output_size_bytes: usize,
    /// Number of dependency resolutions
    pub dependency_resolutions: usize,
    /// Most recently executed task ID
    pub last_executed_task: Option<String>,
}

impl Default for PlanExecutionStats {
    fn default() -> Self {
        Self {
            total_tasks_executed: 0,
            successful_tasks: 0,
            failed_tasks: 0,
            total_execution_time_ms: 0,
            avg_task_time_ms: 0,
            total_output_size_bytes: 0,
            dependency_resolutions: 0,
            last_executed_task: None,
        }
    }
}

impl PlanContext {
    /// Create a new plan context
    pub fn new(plan_id: String) -> Self {
        let now = Utc::now();
        Self {
            plan_id,
            task_results: HashMap::new(),
            variables: HashMap::new(),
            outputs: Vec::new(),
            execution_history: VecDeque::new(),
            dependency_graph: HashMap::new(),
            dependency_cache: HashMap::new(),
            stats: PlanExecutionStats::default(),
            created_at: now,
            updated_at: now,
        }
    }
    
    /// Initialize with a dependency graph from tasks
    pub fn with_dependency_graph(mut self, tasks: &[Task]) -> Self {
        for task in tasks {
            self.dependency_graph.insert(task.id.clone(), task.dependencies.clone());
        }
        self
    }

    /// Add a task result to the context with comprehensive tracking
    pub fn add_task_result(&mut self, task_id: String, task_description: String, result: TaskResult) {
        let started_at = Utc::now() - chrono::Duration::milliseconds(result.execution_time_ms as i64);
        let completed_at = Utc::now();
        
        // Update execution history
        let task_execution = TaskExecution {
            task_id: task_id.clone(),
            task_description,
            started_at,
            completed_at: Some(completed_at),
            success: result.success,
            duration_ms: Some(result.execution_time_ms),
            error: result.error.clone(),
            output_ids: Vec::new(), // Will be updated when outputs are added
        };
        
        self.execution_history.push_back(task_execution);
        
        // Limit history size to prevent memory bloat
        while self.execution_history.len() > 1000 {
            self.execution_history.pop_front();
        }
        
        // Update statistics
        self.stats.total_tasks_executed += 1;
        self.stats.total_execution_time_ms += result.execution_time_ms;
        
        if result.success {
            self.stats.successful_tasks += 1;
        } else {
            self.stats.failed_tasks += 1;
        }
        
        self.stats.avg_task_time_ms = self.stats.total_execution_time_ms / 
                                     self.stats.total_tasks_executed.max(1) as u64;
        self.stats.last_executed_task = Some(task_id.clone());
        
        // Store the result
        self.task_results.insert(task_id, result);
        self.updated_at = Utc::now();
    }

    /// Get a task result by ID
    pub fn get_task_result(&self, task_id: &str) -> Option<&TaskResult> {
        self.task_results.get(task_id)
    }

    /// Set a variable value
    pub fn set_variable<K, V>(&mut self, key: K, value: V) 
    where 
        K: Into<String>,
        V: serde::Serialize,
    {
        if let Ok(json_value) = serde_json::to_value(value) {
            self.variables.insert(key.into(), json_value);
            self.updated_at = Utc::now();
        }
    }

    /// Get a variable value
    pub fn get_variable(&self, key: &str) -> Option<&serde_json::Value> {
        self.variables.get(key)
    }

    /// Get a variable as a specific type
    pub fn get_variable_as<T>(&self, key: &str) -> Result<Option<T>, serde_json::Error>
    where
        T: serde::de::DeserializeOwned,
    {
        match self.variables.get(key) {
            Some(value) => Ok(Some(serde_json::from_value(value.clone())?)),
            None => Ok(None),
        }
    }

    /// Add an output entry with comprehensive metadata
    pub fn add_output(
        &mut self, 
        task_id: String, 
        description: String, 
        data: serde_json::Value, 
        output_type: String
    ) -> String {
        self.add_output_with_options(task_id, description, data, output_type, None, true, vec![])
    }
    
    /// Add an output entry with full options
    pub fn add_output_with_options(
        &mut self,
        task_id: String,
        description: String,
        data: serde_json::Value,
        output_type: String,
        tags: Option<Vec<String>>,
        available_for_dependencies: bool,
        custom_tags: Vec<String>,
    ) -> String {
        let output_id = Uuid::new_v4().to_string();
        let data_str = serde_json::to_string(&data).unwrap_or_default();
        let size_bytes = data_str.len();
        
        let mut output_tags = custom_tags;
        if let Some(mut tags) = tags {
            output_tags.append(&mut tags);
        }
        
        // Add automatic tags based on output type
        match output_type.as_str() {
            "file_content" => output_tags.push("file".to_string()),
            "command_output" => output_tags.push("command".to_string()),
            "analysis_result" => output_tags.push("analysis".to_string()),
            "generated_code" => {
                output_tags.push("code".to_string());
                output_tags.push("generated".to_string());
            }
            _ => {}
        }
        
        let output = PlanOutput {
            id: output_id.clone(),
            task_id: task_id.clone(),
            description,
            data,
            output_type,
            size_bytes,
            available_for_dependencies,
            tags: output_tags,
            timestamp: Utc::now(),
        };
        
        // Update execution history with output ID
        if let Some(execution) = self.execution_history.iter_mut()
            .rev()
            .find(|exec| exec.task_id == task_id) {
            execution.output_ids.push(output_id.clone());
        }
        
        // Update statistics
        self.stats.total_output_size_bytes += size_bytes;
        
        self.outputs.push(output);
        self.updated_at = Utc::now();
        
        output_id
    }

    /// Get all outputs for a specific task
    pub fn get_task_outputs(&self, task_id: &str) -> Vec<&PlanOutput> {
        self.outputs
            .iter()
            .filter(|output| output.task_id == task_id)
            .collect()
    }

    /// Get outputs by type
    pub fn get_outputs_by_type(&self, output_type: &str) -> Vec<&PlanOutput> {
        self.outputs
            .iter()
            .filter(|output| output.output_type == output_type)
            .collect()
    }

    /// Get all outputs
    pub fn get_all_outputs(&self) -> &[PlanOutput] {
        &self.outputs
    }

    /// Clear all context data
    pub fn clear(&mut self) {
        self.task_results.clear();
        self.variables.clear();
        self.outputs.clear();
        self.execution_history.clear();
        self.dependency_graph.clear();
        self.dependency_cache.clear();
        self.stats = PlanExecutionStats::default();
        self.updated_at = Utc::now();
    }
    
    /// Clear old outputs to manage memory usage
    pub fn cleanup_old_outputs(&mut self, max_outputs: usize, max_age_hours: i64) {
        let cutoff_time = Utc::now() - chrono::Duration::hours(max_age_hours);
        
        // Remove old outputs
        self.outputs.retain(|output| {
            output.timestamp > cutoff_time
        });
        
        // If still too many, keep only the most recent
        if self.outputs.len() > max_outputs {
            self.outputs.sort_by(|a, b| b.timestamp.cmp(&a.timestamp));
            self.outputs.truncate(max_outputs);
        }
        
        // Recalculate output size
        self.stats.total_output_size_bytes = self.outputs.iter()
            .map(|o| o.size_bytes)
            .sum();
        
        self.updated_at = Utc::now();
    }

    /// Get a comprehensive summary of the context for use in LLM prompts
    pub fn get_summary(&self) -> String {
        let mut summary = String::new();
        
        // Add execution statistics
        summary.push_str(&format!("Plan Execution Summary (ID: {}):\n", self.plan_id));
        summary.push_str(&format!(
            "Tasks: {} executed ({} successful, {} failed)\n\
            Total time: {}ms (avg: {}ms per task)\n\
            Output size: {} bytes\n\n",
            self.stats.total_tasks_executed,
            self.stats.successful_tasks,
            self.stats.failed_tasks,
            self.stats.total_execution_time_ms,
            self.stats.avg_task_time_ms,
            self.stats.total_output_size_bytes
        ));
        
        // Add recent execution history
        if !self.execution_history.is_empty() {
            summary.push_str("Recent Task Execution:\n");
            for execution in self.execution_history.iter().rev().take(5) {
                let status = if execution.success { "SUCCESS" } else { "FAILED" };
                let duration = execution.duration_ms.unwrap_or(0);
                summary.push_str(&format!(
                    "- {}: {} ({}ms) - {}\n",
                    execution.task_id,
                    status,
                    duration,
                    execution.task_description
                ));
                
                if let Some(error) = &execution.error {
                    summary.push_str(&format!("  Error: {}\n", error));
                }
            }
            summary.push('\n');
        }
        
        // Add key variables
        if !self.variables.is_empty() {
            summary.push_str("Variables:\n");
            for (key, value) in self.variables.iter().take(10) {
                if let Ok(value_str) = serde_json::to_string_pretty(value) {
                    let truncated = if value_str.len() > 150 {
                        format!("{}... ({} chars)", &value_str[..150], value_str.len())
                    } else {
                        value_str
                    };
                    summary.push_str(&format!("- {}: {}\n", key, truncated));
                }
            }
            
            if self.variables.len() > 10 {
                summary.push_str(&format!("... and {} more variables\n", self.variables.len() - 10));
            }
            summary.push('\n');
        }
        
        // Add important outputs
        let important_outputs: Vec<_> = self.outputs.iter()
            .filter(|o| o.available_for_dependencies || o.output_type == "generated_code")
            .take(10)
            .collect();
            
        if !important_outputs.is_empty() {
            summary.push_str("Key Outputs Available for Dependencies:\n");
            for output in &important_outputs {
                summary.push_str(&format!(
                    "- [{}] {} ({}): {} ({} bytes)\n",
                    output.id[..8].to_string(), // Short ID
                    output.task_id,
                    output.output_type,
                    output.description,
                    output.size_bytes
                ));
                
                if !output.tags.is_empty() {
                    summary.push_str(&format!("  Tags: {}\n", output.tags.join(", ")));
                }
            }
            
            let important_count = important_outputs.len();
            if self.outputs.len() > important_count {
                summary.push_str(&format!(
                    "... and {} more outputs\n", 
                    self.outputs.len() - important_count
                ));
            }
        }
        
        if summary.trim().is_empty() {
            summary.push_str("No context data available yet.");
        }
        
        summary
    }
    
    /// Get outputs for specific dependencies
    pub fn get_dependency_outputs(&mut self, dependency_task_ids: &[String]) -> Result<HashMap<String, serde_json::Value>, String> {
        let mut dependency_data = HashMap::new();
        
        for task_id in dependency_task_ids {
            // Check if we have cached dependency data
            if let Some(cached_data) = self.dependency_cache.get(task_id) {
                dependency_data.insert(task_id.clone(), cached_data.key_data.clone());
                continue;
            }
            
            // Look for outputs from this task
            let task_outputs: Vec<_> = self.outputs.iter()
                .filter(|o| o.task_id == *task_id && o.available_for_dependencies)
                .collect();
            
            if task_outputs.is_empty() {
                continue;
            }
            
            // Combine outputs from this task
            let combined_output = if task_outputs.len() == 1 {
                task_outputs[0].data.clone()
            } else {
                // Multiple outputs - create a structured combination
                let outputs_map: serde_json::Map<String, serde_json::Value> = task_outputs.iter()
                    .enumerate()
                    .map(|(i, output)| (format!("output_{}", i), output.data.clone()))
                    .collect();
                serde_json::Value::Object(outputs_map)
            };
            
            // Cache the dependency data
            let data_str = serde_json::to_string(&combined_output).unwrap_or_default();
            let cache_entry = TaskDependencyData {
                source_task_id: task_id.clone(),
                key_data: combined_output.clone(),
                summary: format!("Dependency data from task {}", task_id),
                cached_at: Utc::now(),
                size_bytes: data_str.len(),
            };
            
            self.dependency_cache.insert(task_id.clone(), cache_entry);
            dependency_data.insert(task_id.clone(), combined_output);
        }
        
        self.stats.dependency_resolutions += 1;
        Ok(dependency_data)
    }

    /// Get the dependency chain for completed tasks
    pub fn get_completed_task_chain(&self) -> Vec<String> {
        self.task_results
            .iter()
            .filter(|(_, result)| result.success)
            .map(|(task_id, _)| task_id.clone())
            .collect()
    }

    /// Check if a task has completed successfully
    pub fn is_task_completed(&self, task_id: &str) -> bool {
        self.task_results
            .get(task_id)
            .map(|result| result.success)
            .unwrap_or(false)
    }

    /// Get failed tasks
    pub fn get_failed_tasks(&self) -> Vec<(String, String)> {
        self.task_results
            .iter()
            .filter(|(_, result)| !result.success)
            .map(|(task_id, result)| {
                (task_id.clone(), result.error.clone().unwrap_or_default())
            })
            .collect()
    }

    /// Get memory usage statistics
    pub fn get_memory_stats(&self) -> PlanContextMemoryStats {
        let total_variables_size = self.variables.iter()
            .map(|(k, v)| k.len() + serde_json::to_string(v).unwrap_or_default().len())
            .sum::<usize>();
            
        let total_cache_size = self.dependency_cache.values()
            .map(|cache| cache.size_bytes)
            .sum::<usize>();
        
        PlanContextMemoryStats {
            total_outputs: self.outputs.len(),
            total_output_size_bytes: self.stats.total_output_size_bytes,
            total_variables: self.variables.len(),
            total_variables_size_bytes: total_variables_size,
            execution_history_entries: self.execution_history.len(),
            dependency_cache_entries: self.dependency_cache.len(),
            dependency_cache_size_bytes: total_cache_size,
            total_estimated_memory_bytes: self.stats.total_output_size_bytes + 
                                        total_variables_size + 
                                        total_cache_size,
        }
    }
    
    /// Export context as JSON for serialization
    pub fn to_json(&self) -> Result<String, serde_json::Error> {
        serde_json::to_string_pretty(self)
    }
    
    /// Export minimal context (without large outputs) as JSON
    pub fn to_minimal_json(&self) -> Result<String, serde_json::Error> {
        let minimal = PlanContextMinimal {
            plan_id: self.plan_id.clone(),
            task_results: self.task_results.clone(),
            variables: self.variables.clone(),
            stats: self.stats.clone(),
            created_at: self.created_at,
            updated_at: self.updated_at,
            output_count: self.outputs.len(),
            execution_history_count: self.execution_history.len(),
        };
        
        serde_json::to_string_pretty(&minimal)
    }
    
    /// Import context from JSON
    pub fn from_json(json: &str) -> Result<Self, serde_json::Error> {
        serde_json::from_str(json)
    }
}

/// Memory usage statistics for plan context
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PlanContextMemoryStats {
    pub total_outputs: usize,
    pub total_output_size_bytes: usize,
    pub total_variables: usize,
    pub total_variables_size_bytes: usize,
    pub execution_history_entries: usize,
    pub dependency_cache_entries: usize,
    pub dependency_cache_size_bytes: usize,
    pub total_estimated_memory_bytes: usize,
}

/// Minimal context representation for serialization
#[derive(Debug, Clone, Serialize, Deserialize)]
struct PlanContextMinimal {
    pub plan_id: String,
    pub task_results: HashMap<String, TaskResult>,
    pub variables: HashMap<String, serde_json::Value>,
    pub stats: PlanExecutionStats,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
    pub output_count: usize,
    pub execution_history_count: usize,
}